import Promise from './promise';
<<<<<<< HEAD

import {
  isFunction,
  isArray
} from './utils';

/**
 `RSVP.map` is similar to JavaScript's native `map` method, except that it
  waits for all promises to become fulfilled before running the `mapFn` on
  each item in given to `promises`. `RSVP.map` returns a promise that will
  become fulfilled with the result of running `mapFn` on the values the promises
  become fulfilled with.
=======
import {
  default as Enumerator
} from './enumerator';
import {
  REJECTED
} from './-internal';

export class MapEnumerator extends Enumerator {
  constructor(Constructor, entries, mapFn, label) {
    super(Constructor, entries, true, label, mapFn);
  }

  _init(Constructor, input, bool, label, mapFn) {
    let len = input.length || 0;
    this.length     = len;
    this._remaining = len;
    this._result = new Array(len);
    this._mapFn = mapFn;

    this._enumerate(input);
  }

  _setResultAt(state, i, value, firstPass) {
    if (firstPass) {
      try {
        this._eachEntry(this._mapFn(value, i), i, false);
      } catch (error) {
        this._settledAt(REJECTED, i, error, false);
      }
    } else {
      this._remaining--;
      this._result[i] = value;
    }
  }
}


/**
 `map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called
  meaning that as soon as any promise resolves its value will be passed to `mapFn`.
  `map` returns a promise that will become fulfilled with the result of running
  `mapFn` on the values the promises become fulfilled with.
>>>>>>> master

  For example:

  ```javascript
<<<<<<< HEAD

  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);
=======
  import { map, resolve } from 'rsvp';

  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
>>>>>>> master
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

<<<<<<< HEAD
  RSVP.map(promises, mapFn).then(function(result){
=======
  map(promises, mapFn).then(function(result){
>>>>>>> master
    // result is [ 2, 3, 4 ]
  });
  ```

<<<<<<< HEAD
  If any of the `promises` given to `RSVP.map` are rejected, the first promise
=======
  If any of the `promises` given to `map` are rejected, the first promise
>>>>>>> master
  that is rejected will be given as an argument to the returned promise's
  rejection handler. For example:

  ```javascript
<<<<<<< HEAD
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error('2'));
  let promise3 = RSVP.reject(new Error('3'));
=======
  import { map, reject, resolve } from 'rsvp';

  let promise1 = resolve(1);
  let promise2 = reject(new Error('2'));
  let promise3 = reject(new Error('3'));
>>>>>>> master
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

<<<<<<< HEAD
  RSVP.map(promises, mapFn).then(function(array){
=======
  map(promises, mapFn).then(function(array){
>>>>>>> master
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === '2'
  });
  ```

<<<<<<< HEAD
  `RSVP.map` will also wait if a promise is returned from `mapFn`. For example,
=======
  `map` will also wait if a promise is returned from `mapFn`. For example,
>>>>>>> master
  say you want to get all comments from a set of blog posts, but you need
  the blog posts first because they contain a url to those comments.

  ```javscript
<<<<<<< HEAD

  let mapFn = function(blogPost){
    // getComments does some ajax and returns an RSVP.Promise that is fulfilled
=======
  import { map } from 'rsvp';

  let mapFn = function(blogPost){
    // getComments does some ajax and returns an Promise that is fulfilled
>>>>>>> master
    // with some comments data
    return getComments(blogPost.comments_url);
  };

<<<<<<< HEAD
  // getBlogPosts does some ajax and returns an RSVP.Promise that is fulfilled
  // with some blog post data
  RSVP.map(getBlogPosts(), mapFn).then(function(comments){
=======
  // getBlogPosts does some ajax and returns an Promise that is fulfilled
  // with some blog post data
  map(getBlogPosts(), mapFn).then(function(comments){
>>>>>>> master
    // comments is the result of asking the server for the comments
    // of all blog posts returned from getBlogPosts()
  });
  ```

  @method map
<<<<<<< HEAD
  @static
  @for RSVP
  @param {Array} promises
  @param {Function} mapFn function to be called on each fulfilled promise.
  @param {String} label optional string for labeling the promise.
=======
  @public
  @static
  @for rsvp
  @param {Array} promises
  @param {Function} mapFn function to be called on each fulfilled promise.
  @param {String} [label] optional string for labeling the promise.
>>>>>>> master
  Useful for tooling.
  @return {Promise} promise that is fulfilled with the result of calling
  `mapFn` on each fulfilled promise or value when they become fulfilled.
   The promise will be rejected if any of the given `promises` become rejected.
<<<<<<< HEAD
  @static
*/
export default function map(promises, mapFn, label) {
  if (!isArray(promises)) {
    return Promise.reject(new TypeError("RSVP.map must be called with an array"), label);
  }

  if (!isFunction(mapFn)) {
    return Promise.reject(new TypeError("RSVP.map expects a function as a second argument"), label);
  }

  return Promise.all(promises, label).then(values => {
    let length = values.length;
    let results = new Array(length);

    for (let i = 0; i < length; i++) {
      results[i] = mapFn(values[i]);
    }

    return Promise.all(results, label);
  });
=======
*/
export default function map(promises, mapFn, label) {
  if (typeof mapFn !== 'function') {
    return Promise.reject(new TypeError("map expects a function as a second argument"), label);
  }

  return Promise.resolve(promises, label)
    .then(function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("map must be called with an array");
      }
      return new MapEnumerator(Promise, promises, mapFn, label).promise;
    });
>>>>>>> master
}
