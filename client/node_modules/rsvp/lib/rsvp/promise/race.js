import {
<<<<<<< HEAD
  isArray
} from "../utils";

import {
=======
>>>>>>> master
  noop,
  resolve,
  reject,
  subscribe,
  PENDING
} from '../-internal';

/**
<<<<<<< HEAD
  `RSVP.Promise.race` returns a new promise which is settled in the same way as the
=======
  `Promise.race` returns a new promise which is settled in the same way as the
>>>>>>> master
  first passed promise to settle.

  Example:

  ```javascript
<<<<<<< HEAD
  let promise1 = new RSVP.Promise(function(resolve, reject){
=======
  import Promise from 'rsvp';

  let promise1 = new Promise(function(resolve, reject){
>>>>>>> master
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

<<<<<<< HEAD
  let promise2 = new RSVP.Promise(function(resolve, reject){
=======
  let promise2 = new Promise(function(resolve, reject){
>>>>>>> master
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

<<<<<<< HEAD
  RSVP.Promise.race([promise1, promise2]).then(function(result){
=======
  Promise.race([promise1, promise2]).then(function(result){
>>>>>>> master
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

<<<<<<< HEAD
  `RSVP.Promise.race` is deterministic in that only the state of the first
=======
  `Promise.race` is deterministic in that only the state of the first
>>>>>>> master
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
<<<<<<< HEAD
  let promise1 = new RSVP.Promise(function(resolve, reject){
=======
  import Promise from 'rsvp';

  let promise1 = new Promise(function(resolve, reject){
>>>>>>> master
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

<<<<<<< HEAD
  let promise2 = new RSVP.Promise(function(resolve, reject){
=======
  let promise2 = new Promise(function(resolve, reject){
>>>>>>> master
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

<<<<<<< HEAD
  RSVP.Promise.race([promise1, promise2]).then(function(result){
=======
  Promise.race([promise1, promise2]).then(function(result){
>>>>>>> master
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
<<<<<<< HEAD
  RSVP.Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} entries array of promises to observe
  @param {String} label optional string for describing the promise returned.
=======
  import Promise from 'rsvp';

  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @for Promise
  @static
  @param {Array} entries array of promises to observe
  @param {String} [label] optional string for describing the promise returned.
>>>>>>> master
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
export default function race(entries, label) {
  /*jshint validthis:true */
  let Constructor = this;

  let promise = new Constructor(noop, label);

<<<<<<< HEAD
  if (!isArray(entries)) {
=======
  if (!Array.isArray(entries)) {
>>>>>>> master
    reject(promise, new TypeError('Promise.race must be called with an array'));
    return promise;
  }

  for (let i = 0; promise._state === PENDING && i < entries.length; i++) {
<<<<<<< HEAD
    subscribe(Constructor.resolve(entries[i]), undefined,
      value  => resolve(promise, value),
      reason => reject(promise, reason));
=======
    subscribe(
      Constructor.resolve(entries[i]), undefined,
      value  => resolve(promise, value),
      reason => reject(promise, reason)
    );
>>>>>>> master
  }

  return promise;
}
