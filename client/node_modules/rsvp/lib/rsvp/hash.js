import Promise from './promise';
import PromiseHash from './promise-hash';
<<<<<<< HEAD
import { isObject } from './utils';

/**
  `RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array
=======

/**
  `hash` is similar to `all`, but takes an object instead of an array
>>>>>>> master
  for its `promises` argument.

  Returns a promise that is fulfilled when all the given promises have been
  fulfilled, or rejected if any of them become rejected. The returned promise
  is fulfilled with a hash that has the same key names as the `promises` object
  argument. If any of the values in the object are not promises, they will
  simply be copied over to the fulfilled object.

  Example:

  ```javascript
  let promises = {
<<<<<<< HEAD
    myPromise: RSVP.resolve(1),
    yourPromise: RSVP.resolve(2),
    theirPromise: RSVP.resolve(3),
    notAPromise: 4
  };

  RSVP.hash(promises).then(function(hash){
=======
    myPromise: resolve(1),
    yourPromise: resolve(2),
    theirPromise: resolve(3),
    notAPromise: 4
  };

  hash(promises).then(function(hash){
>>>>>>> master
    // hash here is an object that looks like:
    // {
    //   myPromise: 1,
    //   yourPromise: 2,
    //   theirPromise: 3,
    //   notAPromise: 4
    // }
  });
<<<<<<< HEAD
  ````

  If any of the `promises` given to `RSVP.hash` are rejected, the first promise
=======
  ```

  If any of the `promises` given to `hash` are rejected, the first promise
>>>>>>> master
  that is rejected will be given as the reason to the rejection handler.

  Example:

  ```javascript
  let promises = {
<<<<<<< HEAD
    myPromise: RSVP.resolve(1),
    rejectedPromise: RSVP.reject(new Error('rejectedPromise')),
    anotherRejectedPromise: RSVP.reject(new Error('anotherRejectedPromise')),
  };

  RSVP.hash(promises).then(function(hash){
=======
    myPromise: resolve(1),
    rejectedPromise: reject(new Error('rejectedPromise')),
    anotherRejectedPromise: reject(new Error('anotherRejectedPromise')),
  };

  hash(promises).then(function(hash){
>>>>>>> master
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === 'rejectedPromise'
  });
  ```

<<<<<<< HEAD
  An important note: `RSVP.hash` is intended for plain JavaScript objects that
  are just a set of keys and values. `RSVP.hash` will NOT preserve prototype
=======
  An important note: `hash` is intended for plain JavaScript objects that
  are just a set of keys and values. `hash` will NOT preserve prototype
>>>>>>> master
  chains.

  Example:

  ```javascript
<<<<<<< HEAD
  function MyConstructor(){
    this.example = RSVP.resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: RSVP.resolve('Proto Property')
=======
  import { hash, resolve } from 'rsvp';
  function MyConstructor(){
    this.example = resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: resolve('Proto Property')
>>>>>>> master
  };

  let myObject = new MyConstructor();

<<<<<<< HEAD
  RSVP.hash(myObject).then(function(hash){
=======
  hash(myObject).then(function(hash){
>>>>>>> master
    // protoProperty will not be present, instead you will just have an
    // object that looks like:
    // {
    //   example: 'Example'
    // }
    //
    // hash.hasOwnProperty('protoProperty'); // false
    // 'undefined' === typeof hash.protoProperty
  });
  ```

  @method hash
<<<<<<< HEAD
  @static
  @for RSVP
  @param {Object} object
  @param {String} label optional string that describes the promise.
=======
  @public
  @static
  @for rsvp
  @param {Object} object
  @param {String} [label] optional string that describes the promise.
>>>>>>> master
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all properties of `promises`
  have been fulfilled, or rejected if any of them become rejected.
*/
export default function hash(object, label) {
<<<<<<< HEAD
  if (!isObject(object)) {
    return Promise.reject(new TypeError("Promise.hash must be called with an object"), label);
  }

  return new PromiseHash(Promise, object, label).promise;
=======
  return Promise.resolve(object, label)
    .then(function(object) {
      if (object === null || typeof object !== 'object') {
        throw new TypeError("Promise.hash must be called with an object");
      }
      return new PromiseHash(Promise, object, label).promise;
    });
>>>>>>> master
}
