<<<<<<< HEAD
{"version":3,"file":"immer.module.js","sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue ? \"replace\" : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                  ? {op: \"add\", path, value: origValue}\n                  : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            const path = patch.path.slice()\n            const key = path.pop()\n            const base = path.reduce((current, part) => {\n                if (!current)\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            patch.path.join(\"/\")\n                    )\n                return current[part]\n            }, draft)\n            if (!base)\n                throw new Error(\n                    \"Cannot apply patch, path doesn't resolve: \" +\n                        patch.path.join(\"/\")\n                )\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function original(value) {\n    if (value && value[PROXY_STATE]) {\n        return value[PROXY_STATE].base\n    }\n    // otherwise return undefined\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base, key) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base, key)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies, original} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies, NOTHING} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined\n            ? baseState\n            : normalizeResult(returnValue)\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return normalizeResult(\n        getUseProxies()\n            ? produceProxy(baseState, producer, patchListener)\n            : produceEs5(baseState, producer, patchListener)\n    )\n}\n\nfunction normalizeResult(result) {\n    return result === NOTHING ? undefined : result\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport const nothing = NOTHING\n"],"names":["generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","generateArrayPatches","generateObjectPatches","shared","Math","min","length","i","assigned","path","concat","push","op","value","key","assignedValue","origValue","applyPatches","draft","patch","slice","pop","base","reduce","current","part","Error","join","NOTHING","Symbol","PROXY_STATE","RETURNED_AND_MODIFIED_ERROR","verifyMinified","inProduction","process","env","NODE_ENV","name","autoFreeze","useProxies","Proxy","setAutoFreeze","enableAutoFreeze","setUseProxies","getUseProxies","isProxy","isProxyable","proto","Object","getPrototypeOf","prototype","freeze","original","assign","target","has","shallowCopy","__proto__","undefined","create","each","cb","thing","prop","hasOwnProperty","call","finalize","modified","finalized","copy","result","finalizeObject","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","source","Reflect","ownKeys","arrayTraps","fn","arguments","apply","deleteProperty","isNaN","parseInt","set","createState","get","createProxy","getOwnPropertyDescriptor","owner","descriptor","configurable","defineProperty","markChanged","parentState","proxy","revocable","produceProxy","baseState","producer","patchListener","returnValue","previousProxies","rootProxy","_","p","revoke","descriptors","states","hasCopy","finalizing","prepareCopy","createPropertyProxy","assertUnfinished","finished","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","markChangesRecursively","object","index","diffKeys","added","removed","from","to","a","keys","b","filter","indexOf","baseKeys","shallowEqual","produceEs5","prevStates","objA","objB","keysA","keysB","createHiddenProperty","produce","initialState","recipe","args","currentState","normalizeResult","applyPatchesImpl","nothing"],"mappings":"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"}
=======
{"version":3,"file":"immer.module.js","sources":["../src/common.js","../src/patches.js","../src/es5.js","../src/proxy.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        for (let key in value) cb(key, value[key], value)\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nexport function generateArrayPatches(state, basePath, patches, inversePatches) {\n    const {base, copy, assigned} = state\n    const minLength = Math.min(base.length, copy.length)\n\n    // Look for replaced indices.\n    for (let i = 0; i < minLength; i++) {\n        if (assigned[i] && base[i] !== copy[i]) {\n            const path = basePath.concat(i)\n            patches.push({op: \"replace\", path, value: copy[i]})\n            inversePatches.push({op: \"replace\", path, value: base[i]})\n        }\n    }\n\n    // Did the array expand?\n    if (minLength < copy.length) {\n        for (let i = minLength; i < copy.length; i++) {\n            patches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: copy[i]\n            })\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: base.length\n        })\n    }\n\n    // ...or did it shrink?\n    else if (minLength < base.length) {\n        patches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: copy.length\n        })\n        for (let i = minLength; i < base.length; i++) {\n            inversePatches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: base[i]\n            })\n        }\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === base && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key !== base.length - 1)\n                            throw new Error(`Only the last index of an array can be removed, index: ${key}, length: ${base.length}`) // prettier-ignore\n                        base.length -= 1\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\nconst descriptors = {}\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\nexport function willFinalize(result, baseDraft, needPatches) {\n    const scope = currentScope()\n    scope.forEach(state => (state.finalizing = true))\n    if (result === undefined || result === baseDraft) {\n        if (needPatches) markChangesRecursively(baseDraft)\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope)\n    }\n}\n\nexport function createDraft(base, parent) {\n    let draft\n    if (isDraft(base)) {\n        const state = base[DRAFT_STATE]\n        // Avoid creating new drafts when copying.\n        state.finalizing = true\n        draft = shallowCopy(state.draft)\n        state.finalizing = false\n    } else {\n        draft = shallowCopy(base)\n    }\n    each(base, prop => {\n        Object.defineProperty(draft, \"\" + prop, createPropertyProxy(\"\" + prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const state = {\n        scope: parent ? parent.scope : currentScope(),\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    state.scope.push(state)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createDraft(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = shallowCopy(state.base)\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(scope) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = scope.length - 1; i >= 0; i--) {\n        const state = scope[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[keys[i]] === undefined && !has(base, keys[i])) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createDraft(base, parent) {\n    const state = {\n        // Track which produce call this is associated with.\n        scope: parent ? parent.scope : currentScope(),\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    state.scope.push(state)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createDraft(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.drafts, prop)\n        ? state.drafts\n        : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    is,\n    isDraft,\n    isDraftable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n            if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n        }\n\n        let result\n        // Only create proxies for plain objects/arrays.\n        if (!isDraftable(base)) {\n            result = recipe(base)\n            if (result === undefined) return base\n        }\n        // See #100, don't nest producers\n        else if (isDraft(base)) {\n            result = recipe.call(base, base)\n            if (result === undefined) return base\n        }\n        // The given value must be proxied.\n        else {\n            this.scopes.push([])\n            const baseDraft = this.createDraft(base)\n            try {\n                result = recipe.call(baseDraft, baseDraft)\n                this.willFinalize(result, baseDraft, !!patchListener)\n\n                // Never generate patches when no listener exists.\n                var patches = patchListener && [],\n                    inversePatches = patchListener && []\n\n                // Finalize the modified draft...\n                if (result === undefined || result === baseDraft) {\n                    result = this.finalize(\n                        baseDraft,\n                        [],\n                        patches,\n                        inversePatches\n                    )\n                }\n                // ...or use a replacement value.\n                else {\n                    // Users must never modify the draft _and_ return something else.\n                    if (baseDraft[DRAFT_STATE].modified)\n                        throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\n                    // Finalize the replacement in case it contains (or is) a subset of the draft.\n                    if (isDraftable(result)) result = this.finalize(result)\n\n                    if (patchListener) {\n                        patches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: result\n                        })\n                        inversePatches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: base\n                        })\n                    }\n                }\n            } finally {\n                this.currentScope().forEach(state => state.revoke())\n                this.scopes.pop()\n            }\n            patchListener && patchListener(patches, inversePatches)\n        }\n        // Normalize the result.\n        return result === NOTHING ? undefined : result\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, patches, inversePatches) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft)\n        }\n        // Never finalize drafts owned by an outer scope.\n        if (state.scope !== this.currentScope()) {\n            return draft\n        }\n        if (!state.modified) return state.base\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, patches, inversePatches)\n            if (this.onDelete) {\n                const {assigned} = state\n                for (const prop in assigned)\n                    assigned[prop] || this.onDelete(state, prop)\n            }\n            if (this.onCopy) this.onCopy(state)\n\n            // Nested producers must never auto-freeze their result,\n            // because it may contain drafts from parent producers.\n            if (this.autoFreeze && this.scopes.length === 1) {\n                Object.freeze(state.copy)\n            }\n\n            if (patches) generatePatches(state, path, patches, inversePatches)\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, path, patches, inversePatches) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            root = this.useProxies\n                ? state.copy\n                : (state.copy = shallowCopy(state.draft))\n        }\n\n        const {onAssign} = this\n        const finalizeProperty = (prop, value, parent) => {\n            // Only `root` can be a draft in here.\n            const inDraft = !!state && parent === root\n\n            if (isDraft(value)) {\n                // prettier-ignore\n                parent[prop] = value =\n                    // Patches are never generated for assigned properties.\n                    patches && inDraft && !state.assigned[prop]\n                        ? this.finalize(value, path.concat(prop), patches, inversePatches)\n                        : this.finalize(value)\n\n                // Unchanged drafts are ignored.\n                if (inDraft && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (inDraft && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (inDraft && onAssign) {\n                onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = value => immer.setAutoFreeze(value)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = value => immer.setUseProxies(value)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport {original, isDraft, NOTHING as nothing} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","original","base","assign","target","key","has","shallowCopy","slice","__proto__","undefined","create","each","cb","i","length","thing","prop","hasOwnProperty","call","is","x","y","generatePatches","state","basePath","patches","inversePatches","generateArrayPatches","generateObjectPatches","copy","assigned","minLength","Math","min","path","concat","push","op","assignedValue","origValue","applyPatches","draft","patch","Error","join","descriptors","scopes","currentScope","willFinalize","result","baseDraft","needPatches","scope","forEach","finalizing","markChangesRecursively","createDraft","parent","defineProperty","createPropertyProxy","revoke","revoked","source","get","set","modified","markChanged","prepareCopy","assertUnrevoked","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","object","keys","descriptor","getOwnPropertyDescriptor","createHiddenProperty","Proxy","revocable","arrayTraps","objectTraps","proxy","Reflect","ownKeys","fn","arguments","apply","deleteProperty","isNaN","parseInt","drafts","finalized","isUnchanged","owner","configurable","verifyMinified","configDefaults","process","env","NODE_ENV","name","Immer","config","setUseProxies","useProxies","produce","bind","recipe","patchListener","defaultBase","args","finalize","pop","autoFreeze","modernProxy","legacyProxy","isFrozen","finalizeTree","onDelete","onCopy","freeze","root","onAssign","finalizeProperty","inDraft","immer","setAutoFreeze","applyPatchesImpl"],"mappings":"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"}
>>>>>>> master
