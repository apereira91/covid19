/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/
"use strict";
const EntrypointsOverSizeLimitWarning = require("./EntrypointsOverSizeLimitWarning");
const AssetsOverSizeLimitWarning = require("./AssetsOverSizeLimitWarning");
const NoAsyncChunksWarning = require("./NoAsyncChunksWarning");

<<<<<<< HEAD
=======
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Entrypoint")} Entrypoint */

>>>>>>> master
module.exports = class SizeLimitsPlugin {
	constructor(options) {
		this.hints = options.hints;
		this.maxAssetSize = options.maxAssetSize;
		this.maxEntrypointSize = options.maxEntrypointSize;
		this.assetFilter = options.assetFilter;
	}
<<<<<<< HEAD
=======

	/**
	 * @param {Compiler} compiler webpack compiler
	 * @returns {void}
	 */
>>>>>>> master
	apply(compiler) {
		const entrypointSizeLimit = this.maxEntrypointSize;
		const assetSizeLimit = this.maxAssetSize;
		const hints = this.hints;
<<<<<<< HEAD
		const assetFilter = this.assetFilter || (asset => !asset.endsWith(".map"));
=======
		const assetFilter =
			this.assetFilter || ((name, source, info) => !info.development);
>>>>>>> master

		compiler.hooks.afterEmit.tap("SizeLimitsPlugin", compilation => {
			const warnings = [];

<<<<<<< HEAD
			const getEntrypointSize = entrypoint =>
				entrypoint.getFiles().reduce((currentSize, file) => {
					if (assetFilter(file) && compilation.assets[file]) {
						return currentSize + compilation.assets[file].size();
=======
			/**
			 * @param {Entrypoint} entrypoint an entrypoint
			 * @returns {number} the size of the entrypoint
			 */
			const getEntrypointSize = entrypoint =>
				entrypoint.getFiles().reduce((currentSize, file) => {
					const asset = compilation.getAsset(file);
					if (
						asset &&
						assetFilter(asset.name, asset.source, asset.info) &&
						asset.source
					) {
						return currentSize + (asset.info.size || asset.source.size());
>>>>>>> master
					}

					return currentSize;
				}, 0);

			const assetsOverSizeLimit = [];
<<<<<<< HEAD
			for (const assetName of Object.keys(compilation.assets)) {
				if (!assetFilter(assetName)) {
					continue;
				}

				const asset = compilation.assets[assetName];
				const size = asset.size();
				if (size > assetSizeLimit) {
					assetsOverSizeLimit.push({
						name: assetName,
						size: size
					});
					asset.isOverSizeLimit = true;
				}
			}

			const entrypointsOverLimit = [];
			for (const pair of compilation.entrypoints) {
				const name = pair[0];
				const entry = pair[1];
=======
			for (const { name, source, info } of compilation.getAssets()) {
				if (!assetFilter(name, source, info) || !source) {
					continue;
				}

				const size = info.size || source.size();
				if (size > assetSizeLimit) {
					assetsOverSizeLimit.push({
						name,
						size
					});
					/** @type {any} */ (source).isOverSizeLimit = true;
				}
			}

			const fileFilter = name => {
				const asset = compilation.getAsset(name);
				return asset && assetFilter(asset.name, asset.source, asset.info);
			};

			const entrypointsOverLimit = [];
			for (const [name, entry] of compilation.entrypoints) {
>>>>>>> master
				const size = getEntrypointSize(entry);

				if (size > entrypointSizeLimit) {
					entrypointsOverLimit.push({
						name: name,
						size: size,
<<<<<<< HEAD
						files: entry.getFiles().filter(assetFilter)
					});
					entry.isOverSizeLimit = true;
=======
						files: entry.getFiles().filter(fileFilter)
					});
					/** @type {any} */ (entry).isOverSizeLimit = true;
>>>>>>> master
				}
			}

			if (hints) {
				// 1. Individual Chunk: Size < 250kb
				// 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb
				// 3. No Async Chunks
				// if !1, then 2, if !2 return
				if (assetsOverSizeLimit.length > 0) {
					warnings.push(
						new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)
					);
				}
				if (entrypointsOverLimit.length > 0) {
					warnings.push(
						new EntrypointsOverSizeLimitWarning(
							entrypointsOverLimit,
							entrypointSizeLimit
						)
					);
				}

				if (warnings.length > 0) {
					const hasAsyncChunks =
						compilation.chunks.filter(chunk => !chunk.canBeInitial()).length >
						0;

					if (!hasAsyncChunks) {
						warnings.push(new NoAsyncChunksWarning());
					}

					if (hints === "error") {
						compilation.errors.push(...warnings);
					} else {
						compilation.warnings.push(...warnings);
					}
				}
			}
		});
	}
};
