'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD

var _jestMessageUtil = require('jest-message-util');

// Try getting the real promise object from the context, if available. Someone
// could have overridden it in a test.
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

const Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

class Jasmine2Reporter {
  constructor(globalConfig, config, testPath) {
=======
exports.default = void 0;

var _jestMessageUtil = require('jest-message-util');

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

class Jasmine2Reporter {
  constructor(globalConfig, config, testPath) {
    _defineProperty(this, '_testResults', void 0);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_currentSuites', void 0);

    _defineProperty(this, '_resolve', void 0);

    _defineProperty(this, '_resultsPromise', void 0);

    _defineProperty(this, '_startTimes', void 0);

    _defineProperty(this, '_testPath', void 0);

>>>>>>> master
    this._globalConfig = globalConfig;
    this._config = config;
    this._testPath = testPath;
    this._testResults = [];
    this._currentSuites = [];
    this._resolve = null;
    this._resultsPromise = new Promise(resolve => (this._resolve = resolve));
    this._startTimes = new Map();
  }

<<<<<<< HEAD
  specStarted(spec) {
    this._startTimes.set(spec.id, Date.now());
=======
  jasmineStarted(_runDetails) {}

  specStarted(spec) {
    this._startTimes.set(spec.id, jestNow());
>>>>>>> master
  }

  specDone(result) {
    this._testResults.push(
      this._extractSpecResults(result, this._currentSuites.slice(0))
    );
  }

  suiteStarted(suite) {
    this._currentSuites.push(suite.description);
  }

<<<<<<< HEAD
  suiteDone() {
    this._currentSuites.pop();
  }

  jasmineDone() {
    let numFailingTests = 0;
    let numPassingTests = 0;
    let numPendingTests = 0;
=======
  suiteDone(_result) {
    this._currentSuites.pop();
  }

  jasmineDone(_runDetails) {
    let numFailingTests = 0;
    let numPassingTests = 0;
    let numPendingTests = 0;
    let numTodoTests = 0;
>>>>>>> master
    const testResults = this._testResults;
    testResults.forEach(testResult => {
      if (testResult.status === 'failed') {
        numFailingTests++;
      } else if (testResult.status === 'pending') {
        numPendingTests++;
<<<<<<< HEAD
=======
      } else if (testResult.status === 'todo') {
        numTodoTests++;
>>>>>>> master
      } else {
        numPassingTests++;
      }
    });
<<<<<<< HEAD

=======
>>>>>>> master
    const testResult = {
      console: null,
      failureMessage: (0, _jestMessageUtil.formatResultsErrors)(
        testResults,
        this._config,
        this._globalConfig,
        this._testPath
      ),
<<<<<<< HEAD
      numFailingTests: numFailingTests,
      numPassingTests: numPassingTests,
      numPendingTests: numPendingTests,
=======
      numFailingTests,
      numPassingTests,
      numPendingTests,
      numTodoTests,
>>>>>>> master
      perfStats: {
        end: 0,
        start: 0
      },
      snapshot: {
        added: 0,
        fileDeleted: false,
        matched: 0,
        unchecked: 0,
        unmatched: 0,
        updated: 0
      },
      testFilePath: this._testPath,
<<<<<<< HEAD
      testResults: testResults
=======
      testResults
>>>>>>> master
    };

    this._resolve(testResult);
  }

  getResults() {
    return this._resultsPromise;
  }

  _addMissingMessageToStack(stack, message) {
    // Some errors (e.g. Angular injection error) don't prepend error.message
    // to stack, instead the first line of the stack is just plain 'Error'
<<<<<<< HEAD
    const ERROR_REGEX = /^Error\s*\n/;
    if (
      stack &&
      message &&
      ERROR_REGEX.test(stack) &&
      stack.indexOf(message) === -1
    ) {
      return message + stack.replace(ERROR_REGEX, '\n');
    }
=======
    const ERROR_REGEX = /^Error:?\s*\n/;

    if (stack && message && !stack.includes(message)) {
      return message + stack.replace(ERROR_REGEX, '\n');
    }

>>>>>>> master
    return stack;
  }

  _extractSpecResults(specResult, ancestorTitles) {
    const start = this._startTimes.get(specResult.id);
<<<<<<< HEAD
    const duration = start ? Date.now() - start : undefined;
=======

    const duration = start ? jestNow() - start : undefined;
>>>>>>> master
    const status =
      specResult.status === 'disabled' ? 'pending' : specResult.status;
    const location = specResult.__callsite
      ? {
          column: specResult.__callsite.getColumnNumber(),
<<<<<<< HEAD
          // $FlowFixMe: https://github.com/facebook/flow/issues/5213
=======
>>>>>>> master
          line: specResult.__callsite.getLineNumber()
        }
      : null;
    const results = {
<<<<<<< HEAD
      ancestorTitles: ancestorTitles,
      duration: duration,
      failureMessages: [],
      fullName: specResult.fullName,
      location: location,
      numPassingAsserts: 0, // Jasmine2 only returns an array of failed asserts.
      status: status,
      title: specResult.description
    };

=======
      ancestorTitles,
      duration,
      failureMessages: [],
      fullName: specResult.fullName,
      location,
      numPassingAsserts: 0,
      // Jasmine2 only returns an array of failed asserts.
      status,
      title: specResult.description
    };
>>>>>>> master
    specResult.failedExpectations.forEach(failed => {
      const message =
        !failed.matcherName && failed.stack
          ? this._addMissingMessageToStack(failed.stack, failed.message)
          : failed.message || '';
      results.failureMessages.push(message);
    });
<<<<<<< HEAD

    return results;
  }
}
=======
    return results;
  }
}

>>>>>>> master
exports.default = Jasmine2Reporter;
